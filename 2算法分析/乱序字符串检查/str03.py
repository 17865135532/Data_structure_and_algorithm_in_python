"""
穷举法

解决这类问题的强力方法是穷举所有可能性。
对于乱序检测，我们可以生成 s1 的所有乱序字符串列表，然后查看是不是有 s2。
这种方法有一点困难。当 s1 生成所有可能的字符串时，第一个位置有 n 种可能，第二个位置有 n-1 种，第三个位置有 n-3 种，等等。
总数为 n∗(n−1)∗(n−2)∗...∗3∗2∗1n∗(n−1)∗(n−2)∗...∗3∗2∗1， 即 n!。
虽然一些字符串可能是重复的，程序也不可能提前知道这样，所以他仍然会生成 n! 个字符串。

事实证明，n! 比 n^2 增长还快，
事实上，如果 s1 有 20个字符长，则将有 20! = 2,432,902,008,176,640,000 个字符串产生。
如果我们每秒处理一种可能字符串，那么需要 77,146,816,596 年才能过完整个列表。所以这不是很好的解决方案。
"""
'''
@Time    : 2018/2/4 下午2:49
@Author  : scrappy_zhang
@File    : str03.py
'''